# Default values for sample-app
# This demonstrates all comind-ops Platform capabilities

# Global configuration
global:
  environment: development
  domain: dev.127.0.0.1.nip.io
  namespace: sample-app-dev

# Replica configuration
replicaCount: 1

# Application image configuration
image:
  repository: nginx
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion
  tag: "1.21-alpine"

# Image pull secrets for private registries
imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Service account configuration
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use
  name: ""

# Pod annotations
podAnnotations:
  # Prometheus scraping
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/metrics"

# Pod security context (demonstrates security best practices)
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 3000
  fsGroup: 2000

# Container security context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
    - ALL
  # runAsNonRoot: true
  # runAsUser: 1000

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  # Additional ports for different services
  additionalPorts:
    - name: metrics
      port: 9090
      targetPort: 9090
    - name: health
      port: 8081  
      targetPort: 8081

# Ingress configuration (demonstrates platform ingress)
ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/enable-cors: "true"
  hosts:
    - host: sample-app.dev.127.0.0.1.nip.io
      paths:
        - path: /
          pathType: Prefix
        - path: /api
          pathType: Prefix
        - path: /health
          pathType: Prefix
  tls: []

# Resource configuration (demonstrates resource governance)
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

# Horizontal Pod Autoscaler
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Node selection and scheduling
nodeSelector: {}
tolerations: []
affinity: {}

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1
  # maxUnavailable: 1

# Probes configuration (demonstrates health monitoring)
livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready  
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

startupProbe:
  httpGet:
    path: /startup
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5
  failureThreshold: 30

# Volume configuration (demonstrates platform storage)
persistence:
  enabled: true
  storageClass: ""
  accessMode: ReadWriteOnce
  size: 1Gi
  annotations: {}

# Volume mounts (demonstrates writable directories)
volumeMounts:
  - name: tmp
    mountPath: /tmp
  - name: var-cache
    mountPath: /var/cache
  - name: var-log
    mountPath: /var/log
  - name: app-data
    mountPath: /app/data

volumes:
  - name: tmp
    emptyDir: {}
  - name: var-cache
    emptyDir: {}
  - name: var-log
    emptyDir: {}
  - name: app-data
    persistentVolumeClaim:
      claimName: sample-app-data

# Environment variables (demonstrates configuration management)
env:
  # Basic configuration
  NODE_ENV: production
  PORT: "8080"
  LOG_LEVEL: info
  
  # Application configuration
  APP_NAME: sample-app
  APP_VERSION: "1.0.0"
  
  # Feature flags
  ENABLE_METRICS: "true"
  ENABLE_TRACING: "true"
  ENABLE_DEBUG: "false"

# Secret environment variables (demonstrates sealed secrets integration)
secretEnv:
  # Database secrets
  DATABASE_URL: ""
  DATABASE_PASSWORD: ""
  
  # API keys
  EXTERNAL_API_KEY: ""
  JWT_SECRET: ""
  
  # Service credentials
  REDIS_PASSWORD: ""
  SMTP_PASSWORD: ""

# ConfigMap data (demonstrates configuration management)
configMap:
  # Application configuration
  app.properties: |
    # Sample application configuration
    server.port=8080
    logging.level.root=INFO
    management.endpoints.web.exposure.include=health,metrics,info
    
  # Nginx configuration
  nginx.conf: |
    server {
        listen 8080;
        server_name localhost;
        
        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
        
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
        
        location /ready {
            access_log off;
            return 200 "ready\n";
            add_header Content-Type text/plain;
        }
        
        location /startup {
            access_log off;
            return 200 "started\n";
            add_header Content-Type text/plain;
        }
        
        location /metrics {
            access_log off;
            return 200 "# Sample metrics\nsample_requests_total 123\n";
            add_header Content-Type text/plain;
        }
    }

# Platform service integrations
platformServices:
  # Database integration (PostgreSQL)
  database:
    enabled: true
    host: postgres.platform-dev.svc.cluster.local
    port: 5432
    name: sampleapp
    pool:
      min: 2
      max: 10
  
  # Cache integration (Redis) - optional
  cache:
    enabled: false
    host: redis.platform-dev.svc.cluster.local
    port: 6379
    database: 0
    
  # Queue integration (ElasticMQ)
  queue:
    enabled: true
    host: elasticmq.platform-dev.svc.cluster.local
    port: 9324
    region: elasticmq
    queues:
      - default
      - notifications
      - high-priority
  
  # Storage integration (MinIO)
  storage:
    enabled: true
    endpoint: minio.platform-dev.svc.cluster.local:9000
    secure: false
    buckets:
      - sample-app-uploads
      - sample-app-backups

# Monitoring configuration
monitoring:
  # ServiceMonitor for Prometheus
  serviceMonitor:
    enabled: true
    interval: 30s
    scrapeTimeout: 10s
    labels: {}
    
  # Grafana dashboard
  dashboard:
    enabled: true
    labels:
      grafana_dashboard: "1"
      
# Network policy (demonstrates platform security)
networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
      ports:
      - protocol: TCP
        port: 8080
  egress:
    - to:
      - namespaceSelector:
          matchLabels:
            name: platform-dev
      ports:
      - protocol: TCP
        port: 5432  # PostgreSQL
      - protocol: TCP
        port: 9324  # ElasticMQ
      - protocol: TCP
        port: 9000  # MinIO
    - to: []
      ports:
      - protocol: UDP
        port: 53   # DNS

# Init containers (demonstrates initialization patterns)
initContainers:
  # Database migration
  - name: db-migrate
    image: postgres:15-alpine
    command: ['sh', '-c']
    args:
      - |
        echo "Running database migrations..."
        # In real app, run actual migrations
        sleep 5
        echo "Migrations completed"
    env:
      - name: DATABASE_URL
        valueFrom:
          secretKeyRef:
            name: sample-app-secrets
            key: DATABASE_URL

  # Storage bucket creation
  - name: storage-init
    image: minio/mc:latest
    command: ['sh', '-c']
    args:
      - |
        echo "Initializing storage buckets..."
        # Configure MinIO client and create buckets
        mc alias set local ${MINIO_ENDPOINT} ${MINIO_ACCESS_KEY} ${MINIO_SECRET_KEY}
        mc mb local/sample-app-uploads --ignore-existing
        mc mb local/sample-app-backups --ignore-existing
        echo "Storage initialization completed"
    env:
      - name: MINIO_ENDPOINT
        value: "http://minio.platform-dev.svc.cluster.local:9000"
      - name: MINIO_ACCESS_KEY
        valueFrom:
          secretKeyRef:
            name: sample-app-secrets
            key: MINIO_ACCESS_KEY
      - name: MINIO_SECRET_KEY
        valueFrom:
          secretKeyRef:
            name: sample-app-secrets
            key: MINIO_SECRET_KEY

# Jobs for one-time tasks
jobs:
  # Database seeding job
  - name: db-seed
    enabled: false
    image: postgres:15-alpine
    command: ['sh', '-c']
    args:
      - |
        echo "Seeding database with sample data..."
        # Add your seeding logic here
        echo "Database seeding completed"
    restartPolicy: OnFailure
    backoffLimit: 3

# Metrics and observability
telemetry:
  # OpenTelemetry configuration
  tracing:
    enabled: false
    jaegerEndpoint: ""
    samplingRate: 0.1
    
  # Logging configuration  
  logging:
    level: INFO
    format: json
    output: stdout
